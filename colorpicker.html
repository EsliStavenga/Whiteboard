<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <title>Whiteboard boys</title>
    <link href="css/style.css" rel="stylesheet" />
    <style>
        #test2 {
            background: blue;
        }

        #test,
        #test2 {
            position: absolute;
            top: 20%;
            left: 20%;
            width: 300px;
            height: 300px;
        }

        #gradient-bar {
            height: 300px;
            width: 50px;
            top: 20%;
            left: calc(20% + 700px);
            position: absolute;
            border-radius: 4px;
            /* background-image: linear-gradient(to bottom, rgb(255, 0, 0) 0%, rgb(255, 255, 0) 20%, rgb(0, 255, 0) 40%, rgb(0, 255, 255) 60%, rgb(0, 0, 255) 80%, rgb(255, 0, 255) 100%) */
            background-image: linear-gradient(to bottom, rgb(255, 0, 0) 0%, rgb(255, 255, 0) 16%, rgb(0, 255, 0) 33%, rgb(0, 255, 255) 50%, rgb(0, 0, 255) 66%, rgb(255, 0, 255) 83%, rgb(255, 0, 0) 100%)
        }

        #test {

            background-image:
                /* linear-gradient(to top, red, red), */
                linear-gradient(to bottom, transparent 0%, #000 100%),
                linear-gradient(to right, #fff 0%, transparent 100%);
        }

        .canvas-wrapper {
            position: absolute;
            height: 300px;
            width: 300px;
            top: 20%;
            left: calc(20% + 300px + 50px);
        }

        .color-bubble {
            left: 50%;
            top: 50%;
            position: absolute;
            height: 20px;
            width: 20px;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid white;
            border-radius: 20px;
            /* transition: all .05s linear; */
            z-index: 2;
        }

        .gradient-indicator {
            position: absolute;
            border: 1px solid white;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            height: 5px;
            width: 100%;
            left: 0%;
            top: 50%;
        }

        #canvas {
            position: relative;
            top: 0;
            left: 0;
            z-index: 1;
        }
    </style>
</head>

<body>
    <div id="test2"></div>
    <div id="test"></div>

    <!-- <div class="canvas-wrapper">
        <div class="color-bubble"></div>
        <canvas height="300" width="300" id="canvas"></canvas>
    </div>
 -->
    <div id="gradient-bar">
        <div class="gradient-indicator"></div>
    </div>
    <script src="js/Line.js"></script>
    <script src="js/Segment.js"></script>
    <script src="js/Shape/Shape.js"></script>
    <script src="js/Shape/Square.js"></script>
    <script src="js/Event.js"></script>
    <script src="js/Canvas.js"></script>
    <script src="js/ColorPicker/ColorPicker.js"></script>
    <script>
        let body = document.getElementsByTagName("body")[0];
        let gradientBarY = 300;
        //should be the width of the canvas
        let colorOffset = (255 / 300);
        let c = new ColorPicker(300, 300);
        c.appendTo();

        let canvasBounds = c.canvas.canvas.getBoundingClientRect();

        function clamp(val, min, max) {
            return Math.max(min, Math.min(max, val));
        }

        let gradientBarBounds = document.getElementById("gradient-bar").getBoundingClientRect();
        document.querySelectorAll("#gradient-bar, .gradient-indicator").forEach((elem) => {
            elem.onmousemove = (e) => {
                if (e.buttons == 1 && !c.dragging) {
                    //firefox still uses layerY, the new browsers switched to offsetY
                    let y = clamp(e.clientY - gradientBarBounds.top, 0, gradientBarBounds.bottom - gradientBarBounds.top);
                    c.setBackground(c.getRGB(y));
                    c.colorChanged(undefined);
                    document.getElementsByClassName("gradient-indicator")[0].style.top = y + "px";
                }
            };
        });


        //console.log(getRGB(gradientBarY));

        //throw new Error;
    </script>
    <!-- let canvas = document.getElementById("canvas");
        let bubble = document.getElementsByClassName("color-bubble")[0];
        let ctx = canvas.getContext("2d");
        let canvasBounds = canvas.getBoundingClientRect();
        let gradientBarBounds = document.getElementById("gradient-bar").getBoundingClientRect();

        //update the canvas' background based on the gradient
        document.querySelectorAll("#gradient-bar, .gradient-indicator").forEach((elem) => {
            elem.onmousemove = (e) => {
                if (e.buttons == 1 && !dragging) {
                    //firefox still uses layerY, the new browsers switched to offsetY
                    let y = clamp(e.clientY - gradientBarBounds.top, 0, gradientBarBounds.bottom - gradientBarBounds.top);
                    setBackground(getRGB(y));
                    colorChanged(undefined);
                    document.getElementsByClassName("gradient-indicator")[0].style.top = y + "px";
                }
            };
        });

        //keep track of whatever to move the bubble
        let dragging = false;
        //whenever the user clicks the canvas or bubble, start dragging the bubble
        document.querySelectorAll("#canvas, .color-bubble").forEach((elem) => {
            elem.onmousedown = (e) => {
                dragging = (e.buttons == 1);
            }
        });

        //once the user lets go of the left mouse button, let go of the bubble
        document.onmouseup = (e) => {
            dragging = false;
        }

        /**
         * 
         * 
         * the value
         * the minimum bound
         * the maximum bound
         */
        function clamp(val, min, max) {
            return Math.max(min, Math.min(max, val));
        }

        //if the user moves the mouse and the left mouse button is pressed, start dragging the bubble
        document.onmousemove = (e) => {
            if (dragging) {
                colorChanged(e);
            }
        }

        function colorChanged(e) {

            //calculate the vertical/horizontal centerpoint
            let halfBubbleHeight = bubble.offsetHeight / 2;
            let halfBubbleWidth = bubble.offsetWidth / 2;

            if (e) {
                //calculate the bubble's position by making the left of the canvas 0, then calculating the amount of pixels the user is from 0
                //clamp the value between -half the bubble and canvas size + half the bubble
                bubble.style.top = clamp((e.clientY - canvasBounds.top) - halfBubbleHeight, -halfBubbleHeight, 300 - halfBubbleHeight) + "px"; //Math.max(-bubble.offsetHeight / 2, Math.min((e.clientY - canvasBounds.top), 300 - bubble.offsetHeight / 2)) + "px";
                bubble.style.left = clamp((e.clientX - canvasBounds.left) - halfBubbleWidth, -halfBubbleWidth, 300 - halfBubbleWidth) + "px"; //Math.max(-bubble.offsetWidth / 2, Math.min(e.clientX - canvasBounds.left, 300 - bubble.offsetWidth / 2)) + "px";

            }

            //parse the float and compensate for the earlier calculated offset
            let x = parseFloat(bubble.style.left) + halfBubbleWidth
            let y = parseFloat(bubble.style.top) + halfBubbleHeight;

            //get the pixel data
            let pixel = ctx.getImageData(Math.min(299, x), Math.min(299, y), 1, 1).data;
            body.style.background = (`rgb(${pixel[0]}, ${pixel[1]}, ${pixel[2]})`);
        }

        /*
        //get the rgb value if someone moves over it
        document.getElementById("canvas").onmousemove = (e) => {
            if (e.buttons == 1) {
                let x, y;

                if (e.offsetY) {
                    y = e.offsetY;
                    x = e.offsetX;
                } else if (e.layerY) {
                    y = e.layerY;
                    x = e.layerX;
                }

                let pixel = ctx.getImageData(x, y, 1, 1).data;
                body.style.background = (`rgb(${pixel[0]}, ${pixel[1]}, ${pixel[2]})`);
                dragging = true;
                startBuggleDrag(x, y);
            }
        } */


        //from left to right
        let whiteGradient = ctx.createLinearGradient(0, 0, 300, 0);

        whiteGradient.addColorStop(0, "#fff");
        whiteGradient.addColorStop(1, "transparent");


        //from bottom to top
        let blackGradient = ctx.createLinearGradient(0, 300, 0, 0);
        blackGradient.addColorStop(0, "#000");
        blackGradient.addColorStop(1, "transparent");

        setBackground("blue");

        //set the background color to the specified color
        function setBackground(color) {

            //clear canvas
            fillCanvas("#000");

            fillCanvas(color);
            fillCanvas(whiteGradient);
            fillCanvas(blackGradient);

        }

        //fill the entire canvas with a specific style
        function fillCanvas(fillStyle) {
            ctx.fillStyle = fillStyle;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        /* SINE AND SQUARE WAVE COMBINED */
        //getr the RGB value from a specific value on the slider
        function getRGB(y) {
            //normalize the result and times the x limit (The limit of the x value of the cosine function)
            //I stuck with 6 because it's easiest to calculate
            let x = ((y * colorOffset) / 255) * 6;
            let leftHalfOfEquation = .75 * (.66666 * Math.PI * x);

            //calculate the sine for blue and green
            let blueSine = (x < 2 ? 0 : calculateCosine(leftHalfOfEquation, 2));
            let greenSine = (x > 4 ? 0 : 2 * calculateCosine(leftHalfOfEquation));
            let redSine;

            //red has the sine of blue until 2, between 2 and 4 nothing, then it has the sine of green
            //as illustrated in my beautiful picture (/img/rgb.psd)
            if (x < 2) {
                redSine = calculateCosine(leftHalfOfEquation, 2);
            } else if (x >= 2 && x <= 4) {
                redSine = 0;
            } else if (x > 4) {
                redSine = calculateCosine(leftHalfOfEquation);
            }

            //cap the result between 0 and 1
            redSine = Math.min(redSine, 1);
            greenSine = Math.min(greenSine, 1);
            blueSine = Math.min(blueSine, 1);

            //multiple the value by the limit of RGB (255)
            return `rgb(${redSine * 255}, ${greenSine * 255}, ${blueSine * 255})`;
        }

        function calculateCosine(leftHalf, piMultiply = 1) {
            return 2 * Math.cos(leftHalf + piMultiply * Math.PI) + 2;
        }

        /*


        ------=========== SINE ===========-----------


        function getRGB(y) {
            //normalize y postiion
            let x = ((y * colorOffset) / 255) * 3;
            console.log(x);

            // let red = (x > 1 && x < 2 ? 0 : ((Math.cos(2.1 * x) + 1) / 2));
            let red = ((Math.cos(2.1 * x) + 1) / 2);
            let green = (x < 0.5 || x > 2 ? 0 : ((Math.cos(4.2 * x + 1) + 1) / 2));
            let blue = (x < 1 || x > 2.5 ? 0 : ((Math.cos(4.2 * x - 1.1) + 1) / 2));

            return `rgb(${ red * 255}, ${ green * 255}, ${ blue * 255})`;
        }

        let count = 0;
        setInterval(function () {
            let rgb = getRGB(count++);
            //console.log(rgb);
            setBackground(rgb);

            if (count > 300) {
                count = 0;
            }
        }, 100);*/

    </script> -->


    <!-- <canvas ssheight="800" width="800" id="test"></canvas> -->

    <!-- <script>
        let canvasElement = document.getElementById("test");
        let ctx = canvasElement.getContext("2d");
        canvasElement.onclick = (e) => {
            let x = e.pageX;
            let y = e.pageY;

            ctx.fillRect(x, y, 20, 20);
        }

    </script> -->

</body>

</html>